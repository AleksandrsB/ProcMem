#pragma once
#include <Windows.h>
#include <TlHelp32.h>
#include <string>
#include <stdexcept>
#include <vector>

/**
 * @class ProcMem
 * @brief A class for reading and writing memory in a process.
 *
 * @author AleksandrsB
 */
class ProcMem
{
private:
	HANDLE			ProcessHandle = nullptr;	/// Handle to the process.
	DWORD			ProcessID = 0;				/// ID of the process.
	std::wstring	ProcessName = L"";			/// Name of the process to be accessed.

public:

	bool			isConnected = false;		/// Indicates whether the process is successfully connected.

public:
	/**
	 * @brief Constructor that initializes ProcMem with the process name and opens a handle to the process.
	 * @param procName The name of the process to connect to.
	 * @throws std::runtime_error If the toolhelp snapshot or process handle could not be created.
	 */
	ProcMem(const std::wstring& procName);

	/**
	 * @brief Destructor that closes the process handle if it is open.
	 */
	~ProcMem();

	/**
	 * @brief Retrieves the base address of a module in the process.
	 * @param moduleName The name of the module whose base address is to be retrieved.
	 * @return The base address of the module, or 0 if the module was not found.
	 * @throws std::runtime_error If creating the toolhelp snapshot fails.
	 */
	std::uintptr_t GetModuleBaseAddress(const std::wstring& moduleName);

	/**
	 * @brief Retrieves the ProcessID (PID)
	 * @return The base address of the module, or 0 if the module was not found.
	 */
	DWORD getProcessID() { return this->ProcessID; }
	HANDLE getProcessHandle() { return this->ProcessHandle; }
	const std::wstring getProcessName() { return this->ProcessName; }

	/**
	 * @brief Reads a value of type T from the specified address in the process memory.
	 * @tparam T The type of the value to be read.
	 * @param fromAddr The address in the process memory to read from.
	 * @return The value read from the memory.
	 * @throws std::runtime_error If reading the memory fails.
	 */
	template<typename T>
	inline T readMemory(std::uintptr_t fromAddr)
	{
		T value;
		if (ReadProcessMemory(ProcessHandle, reinterpret_cast<LPCVOID>(fromAddr), &value, sizeof(T), nullptr))
			return value;
		throw std::runtime_error("Failed to read memory");
	}

	/**
	 * @brief Reads an array of values of type T from the specified address in the process memory.
	 * @tparam T The type of the values to be read.
	 * @param fromAddr The starting address in the process memory to read from.
	 * @param count The number of elements to read.
	 * @return A vector containing the values read from the memory.
	 * @throws std::runtime_error If reading the memory array fails.
	 */
	template<typename T>
	inline std::vector<T> readMemoryArray(std::uintptr_t fromAddr, size_t count)
	{
		std::vector<T> buffer(count);
		if (ReadProcessMemory(ProcessHandle, reinterpret_cast<LPCVOID>(fromAddr), buffer.data(), sizeof(T) * count, nullptr))
			return buffer;
		throw std::runtime_error("Failed to read memory array");
	}

	/**
	 * @brief Writes a value of type T to the specified address in the process memory.
	 * @tparam T The type of the value to be written.
	 * @param toAddr The address in the process memory to write to.
	 * @param value The value to write to the memory.
	 * @return True if the write operation was successful.
	 * @throws std::runtime_error If writing to the memory fails.
	 */
	template<typename T>
	inline bool writeMemory(std::uintptr_t toAddr, T value)
	{
		SIZE_T bytesWritten;
		bool success = WriteProcessMemory(ProcessHandle, reinterpret_cast<LPVOID>(toAddr), reinterpret_cast<LPCVOID>(&value), sizeof(T), &bytesWritten);

		if (!success || (bytesWritten != sizeof(T)))
			throw std::runtime_error("Failed to write memory");
		return true;
	}

	/**
	 * @brief Writes an array of values of type T to the specified address in the process memory.
	 * @tparam T The type of the values to be written.
	 * @param toAddr The starting address in the process memory to write to.
	 * @param values Pointer to the array of values to write.
	 * @param count The number of elements to write.
	 * @return True if the write operation was successful.
	 * @throws std::runtime_error If writing to the memory array fails.
	 */
	template<typename T>
	inline bool writeMemoryArray(std::uintptr_t toAddr, const T* values, size_t count)
	{
		SIZE_T bytesWritten;
		bool success = WriteProcessMemory(ProcessHandle, reinterpret_cast<LPVOID>(toAddr), values, sizeof(T) * count, &bytesWritten);

		if (!success || (bytesWritten != sizeof(T) * count))
			throw std::runtime_error("Failed to write memory array");
		return true;
	}
};
